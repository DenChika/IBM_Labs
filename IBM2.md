# Лабораторная работа IBM2
## Цель работы
Разобраться с алгоритмом, использующим квантовые вычисления
## Задачи, решаемые при выполнении
Разобраться с теорией алгоритма и объяснить его работу
## Алгоритм Гровера
### Для чего нужен
Представим, что нам нужно выбрать из N элементов массива один элемент $$\omega $$, подходящий определённому условию.

![image](https://user-images.githubusercontent.com/79001610/172026777-958abd72-da69-470d-a4cd-8cc25f5ab4d7.png)

В данном случае нам в среднем требуется N/2 операций, а в худшем случае все N. Однако с помощью алгоритма Гровера мы сможем достичь цели за $\sqrt{N}$\
### Оракул
Пусть мы имеем $2^{n}$ базисных квантовых состояний, где n - количество кубитов. Для удобства будем считать, что у нас 3 кубита, соответственно 8 основных состояний |000>, |001>, ..., |111> (т.е. |0>, ..., |7>). Для любого такого |x> имеем:

![image](https://user-images.githubusercontent.com/79001610/172027075-33892b08-3846-42ed-846c-7e6632ed751d.png)

Например, если $\omega$ = 101, то оракул будет иметь вид

![image](https://user-images.githubusercontent.com/79001610/172027112-063d55a4-553c-415a-a768-eb453bcf4560.png)

### Работа алгоритма (амплитудное усиление)
Введём термин _равномерной суперпозиции_

![image](https://user-images.githubusercontent.com/79001610/172027410-2d38dd67-a20a-4fde-b4b7-b1edcc037b12.png)

Этой суперпозицией по всем кубитам выражается одинаковая вероятность того, что при измерении суперпозиция бы рухнула в правильное значение $\omega$, и эта вероятность равна 1/$2^{n}$.\
Введём процедуру _амплитудного усиления_, именно так квантовый компьютер повышает эту вероятность. Эта процедура растягивает амплитуду данного элемента и уменьшает амплитуды других элементов.

Алгоритм имеет хорошую геометрическую интерпретацию. Введём ещё одно состояние |s'>, перпендикулярное |$\omega$ >

![image](https://user-images.githubusercontent.com/79001610/172027875-3aa6cfd4-2c98-426a-a796-f992421d9a8f.png)

#### Шаг 1
Строим равномерную суперпозицию

![image](https://user-images.githubusercontent.com/79001610/172027975-a93994fd-b0ae-48c7-b45f-6438ef5e6371.png)

#### Шаг 2
Применяем оракул (отражаем вектор суперпозиции относительно |s'>)

![image](https://user-images.githubusercontent.com/79001610/172028219-a709fe60-7692-4d4c-8379-20de4ee08e13.png)

#### Шаг 3
Применяем дополнительный оракул (отражаем вектор с шага 2 относительно вектора |s>)

![image](https://user-images.githubusercontent.com/79001610/172028844-8d9e93d3-60e0-448e-b174-b402c3747f56.png)

С помощью применения двух оракулов мы приближаем |s> к |$\omega$ >, поэтому алгоритм итеративен, мы повторяем 2 и 3 шаг t раз, тем самым стремимся к тому, чтобы когда-то отразившись, мы попали в |$\omega$ >.

Так как мы имеем дело с малыми углами, то $\theta$ примерно равен 1/$\sqrt{N}$, тогда после t выполнений алгоритма мы получим\
$\theta + 2\theta * t = \pi / 2$ или $1/\sqrt{N} * (1 + 2t) = \pi / 2$,\
то есть $t = \pi*\sqrt{N}/4 - 1/2$,\
что грубо говоря равно $\sqrt{N}$, следовательно нам достаточно примерно $\sqrt{N}$ итераций алгоритма.

### Пример (2 кубита)
Имея N = 4 нетрудно посчитать, что нам достаточно всего одной итерации алгоритма для получения наивысшей вероятности.\
Рассмотрим |$\omega$ > = |11>. В данном случае оракул $\upsilon$ <sub> $\omega$ </sub> действует следующим образом:

![image](https://user-images.githubusercontent.com/79001610/172029819-80e9df1e-4d78-4cd5-a479-bb0a14263c02.png)

или:
  
![image](https://user-images.githubusercontent.com/79001610/172029824-0aa48c76-c35c-4b60-9ff2-400b585d8035.png)

В IBM Compose это представленно в виде:

![image](https://user-images.githubusercontent.com/79001610/172029833-05427247-ca68-4b68-93e5-068f10117a29.png)

Оракул $\upsilon$ <sub> s </sub> выглядит так:

![image](https://user-images.githubusercontent.com/79001610/172030344-932f82a2-95d5-4ddc-85f7-ca5ab268dfaf.png)

![image](https://user-images.githubusercontent.com/79001610/172030352-813cf531-6cef-4734-a5b5-dc24bbbb36f1.png)

Общая схема:

![image](https://user-images.githubusercontent.com/79001610/172030368-305d37aa-ac57-43fd-aa3e-1698bdfe826b.png)

Гейты Адамара перед и после каждого применения оракула нужны для преобразования |s> в |0> и обратно соответственно.

![image](https://user-images.githubusercontent.com/79001610/172030410-7e6de6f2-b1df-4f67-887c-de7a5ac09a3a.png)

## Вывод
Мы рассмотрели алгоритм Гровера, он нужен для быстрого нелинейного поиска нужного элемента в списке. Также объяснили принцип работы алгоритма и разобрали пример с 2мя кубитами, когда нужное нам состояние равно |11>.
